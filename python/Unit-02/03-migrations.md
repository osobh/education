## Migrations with Flask Migrate

### Introduction

In the previous section we saw how to create models and tables with flask_sqlalchemy, but we did not have any kind of versioning for our schema! While this might not seem like a big deal, it is essential to have some kind of management of your schema when dealing with a relational database - and migrations are the tool to use for this. To get migrations set up we will be using the `flask_migrate` module which is an abstraction on `alembic`, a migration tool. We will also be using `flask_script` to run command line scripts to create the migrations folder, migrations and to upgrade/downgrade our migrations.

### Getting started with flask_migrate

Create a virtual environment or just manage this locally, but make sure you have these dependencies

```bash
createdb flask_migrate_app # you will be able to generate a migrations folder, but not able to create a migration until you have created the database
pip3 install flask_script flask_migrate
```

```py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_script import Manager
from flask_migrate import Migrate, MigrateCommand

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite://localhost/flask_migrate_app'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
migrate = Migrate(app, db)

manager = Manager(app)
manager.add_command('db', MigrateCommand)

class Author(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.Text())

if __name__ == '__main__':
    manager.run()
```

With the above application you can create the database or enable migrations if the database already exists with the following command: `python3 app.py db init`

This will add a migrations folder to your application. The contents of this folder need to be added to version control along with your other source files. You can then generate an initial migration: `python app.py db migrate`. The migrations are generated based on what your **models** look like.

Here is what the migration should look like for the model above

```py
"""empty message

Revision ID: 71785b8209b8
Revises: None
Create Date: 2016-06-17 11:40:17.657027

"""

# revision identifiers, used by Alembic.
revision = '71785b8209b8'
down_revision = None

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.create_table('author',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.Text(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('author')
    ### end Alembic commands ###
```

The migration script can be reviewed and edited, as Alembic (the underlying module) does not detect every change you make to your models. Then you can apply the migration to the database by running - `python app.py db upgrade`. 

After running the migration you should see something like:

```bash
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 71785b8209b8, empty message
```

If you decide to undo a migration you can run `python app.py db downgrade`. To see all the commands that are available run this command: `python app.py db --help`

#### Exercise

Refactor [this](https://github.com/gSchool/python-curriculum/tree/master/Exercises/flask_list_crud) application to use migrations. Once you have completed this, add additional migrations for authors so you have full CRUD on authors and books. As a bonus add a migration for tags which is a M:M with books.
